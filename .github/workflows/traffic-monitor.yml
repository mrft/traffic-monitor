name: Scheduled Traffic Monitor


env:
  # Default routes list. Each line is: <start_address>|<end_address>
  # Add more lines to monitor multiple routes.
  ROUTES: |
    120 Carnotstraat, Antwerpen, Belgium|51.215447,4.4447065
  # 412 N12, Antwerpen, Belgium|51.219000,4.425000
  # Antwerpen Centraal Station, Antwerpen, Belgium|51.217222,4.421944

on:
  schedule:
    # IMPORTANT: keep this in sync with 'if:'' statements below (the ones that decide whether to run collect or commit) !!!
    # COLLECT JOB SCHEDULE
    - cron: '*/5 * * * *'        # Every 5 minutes
    # COMMIT JOB SCHEDULE
    - cron: '0 1,8,12,17,20 * * *'  # Every day at 1:00, 8:00, 12:00, 17:00, and 20:00 UTC
  workflow_dispatch:
    inputs:
      job_to_run:
        description: 'Which job to run'
        required: true
        default: 'collect'
        type: choice
        options:
          - collect
          - commit
      routes:
        description: 'Optional multiline routes string to override `ROUTES` env. Each line: start|end'
        required: false
        default: ''
        type: string

# Ensure only one workflow run executes at a time to prevent race conditions
# between collect and commit jobs accessing the same artifact
concurrency:
  group: traffic-monitor
  cancel-in-progress: false

jobs:
  collect:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
    # Schedule (see on.schedule at the top), workflow_dispatch allows manual trigger
    if: (github.event_name == 'schedule' && github.event.schedule == '*/5 * * * *') || (github.event_name == 'workflow_dispatch' && github.event.inputs.job_to_run == 'collect')
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Install Python with uv
        run: uv python install 3.12

      - name: Download existing output artifact from previous runs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Find the latest artifact named output-artifact
          ARTIFACT_ID=$(gh api repos/${{ github.repository }}/actions/artifacts \
            --jq '.artifacts | map(select(.name == "output-artifact" and .expired == false)) | sort_by(.created_at) | last | .id // empty')
          
          if [ -n "$ARTIFACT_ID" ]; then
            echo "Downloading artifact ID: $ARTIFACT_ID"
            gh api repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip > artifact.zip
            if [ -s artifact.zip ]; then
              unzip -o artifact.zip -d ./artifact
              if [ -f ./artifact/output.txt ]; then
                cp ./artifact/output.txt ./output.txt
                echo "Restored output.txt from previous artifact"
              fi
            else
              echo "Downloaded artifact is empty"
            fi
          else
            echo "No previous artifact found"
          fi
          
          # Ensure output.txt exists
          touch output.txt

      - name: Run Python script and append to output.txt
        run: |
          # Prefer workflow_dispatch `routes` input; fall back to top-level env `ROUTES`
          RAW_ROUTES="${{ github.event.inputs.routes || env.ROUTES }}"

          echo "Using routes:"
          echo "$RAW_ROUTES"

          # Iterate over non-empty lines in RAW_ROUTES. Each line should be: start|end
          echo "$RAW_ROUTES" | while IFS= read -r line || [ -n "$line" ]; do
            # skip empty lines
            if [ -z "$(echo "$line" | tr -d '[:space:]')" ]; then
              continue
            fi

            # split on first '|'
            START="$(echo "$line" | awk -F'|' '{print $1}' | sed -e 's/^\s*//;s/\s*$//')"
            END="$(echo "$line" | awk -F'|' '{print $2}' | sed -e 's/^\s*//;s/\s*$//')"

            if [ -z "$START" ] || [ -z "$END" ]; then
              echo "Skipping invalid route line: $line"
              continue
            fi

            echo "Running route: '$START' -> '$END'"
            uv run print_routes.py "$START" "$END" >> output.txt || echo "Route command failed for: $line"
          done
          # log what's in output.txt so far
          echo "Current contents of output.txt:"
          cat output.txt

      - name: Upload output artifact
        uses: actions/upload-artifact@v4
        with:
          name: output-artifact
          path: output.txt
          overwrite: true

  commit:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: write
    # NOT the collect schedule (see on.schedule at the top):
    # when not collecting we'll commit, workflow_dispatch allows manual trigger
    if: (github.event_name == 'schedule' && github.event.schedule != '*/5 * * * *') || (github.event_name == 'workflow_dispatch' && github.event.inputs.job_to_run == 'commit')
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Checkout data branch
        run: |
          DATA_BRANCH="${{ github.ref_name }}_data"
          echo "Checking out data branch: $DATA_BRANCH"
          git fetch origin "$DATA_BRANCH" --depth=1 || {
            echo "Data branch $DATA_BRANCH does not exist. Creating it from current branch."
            git checkout -b "$DATA_BRANCH"
            git push origin "$DATA_BRANCH"
          }
          git checkout "$DATA_BRANCH"

      - name: Download output artifact from previous runs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Find the latest artifact named output-artifact
          ARTIFACT_ID=$(gh api repos/${{ github.repository }}/actions/artifacts \
            --jq '.artifacts | map(select(.name == "output-artifact" and .expired == false)) | sort_by(.created_at) | last | .id // empty')
          
          if [ -n "$ARTIFACT_ID" ]; then
            echo "Downloading artifact ID: $ARTIFACT_ID"
            gh api repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip > artifact.zip
            if [ -s artifact.zip ]; then
              unzip -o artifact.zip -d ./artifact
            else
              echo "Downloaded artifact is empty"
              mkdir -p ./artifact
            fi
          else
            echo "No artifact found"
            mkdir -p ./artifact
          fi

      - name: Append output.txt to data/traffic.tsv
        run: |
          if [ -f ./artifact/output.txt ]; then
            mkdir -p data
            cat ./artifact/output.txt >> data/traffic.tsv
            echo "Appended output.txt content to data/traffic.tsv"
          else
            echo "No output.txt found to append"
          fi

      - name: Commit and push data/traffic.tsv
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add data/traffic.tsv
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update data/traffic.tsv with collected data"
            git push --set-upstream origin "$(git rev-parse --abbrev-ref HEAD)"
          fi

      - name: Delete old artifacts to clear output
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Delete all output-artifact artifacts to start fresh
          ARTIFACT_IDS=$(gh api repos/${{ github.repository }}/actions/artifacts \
            --jq '.artifacts | map(select(.name == "output-artifact")) | .[].id')
          
          for ID in $ARTIFACT_IDS; do
            echo "Deleting artifact ID: $ID"
            gh api -X DELETE repos/${{ github.repository }}/actions/artifacts/$ID || true
          done
          echo "All output artifacts cleared"
